1. word search
https://leetcode.com/problems/word-search/description/
backtracking, starting from every char from the matrix, so the outmost layer is a two level loop. compare the char with 
the word char one by one. If match, then try to go to four directions. use visited to record the path.
推出条件是index == word.length
class Solution {
    public boolean exist(char[][] board, String word) {
        boolean[][] visited = new boolean[board.length][board[0].length];
        for (int i=0; i<board.length; i++) {
            for (int j=0; j<board[0].length; j++) {
                if (dfs(board, word, 0, i, j, visited)) return true;
            }
        }
        return false;
    }
    private boolean dfs(char[][] board, String word, int index, int r, int c, boolean[][] visited) {
        if (index == word.length()) return true;
        if (r < 0 || r >= board.length || c < 0 || c >= board[0].length) return false;
        if (visited[r][c]) return false;
        if (board[r][c] != word.charAt(index)) return false;
        
        visited[r][c] = true;
        if (dfs(board,word,index+1,r+1,c,visited)) return true;
        if (dfs(board,word,index+1,r-1,c,visited)) return true;
        if (dfs(board,word,index+1,r,c+1,visited)) return true;
        if (dfs(board,word,index+1,r,c-1,visited)) return true;
        visited[r][c] = false;
        return false;
        
    }
}
2. word search II
This one need to find all words in dictonary. So we should use trie. User the words to build the trie first.
Then go through the board and search the trie for every char, if it exist and if match a whole word, add to result.
1. should use set to filter duplicated
 ['a', 'a'] ['a'] this will return two 'a' if we do not use set.
 class Solution {
    TrieNode root;
    public List<String> findWords(char[][] board, String[] words) {
        root = new TrieNode();
        
        boolean[][] visited = new boolean[board.length][board[0].length];
        for (String word : words) {
            TrieNode temp = root;
            for (char c : word.toCharArray()) {
                if (temp.children[c-'a'] == null) {
                    temp.children[c-'a'] = new TrieNode();
                }
                temp = temp.children[c-'a'];
            }
            temp.setIsLeaf(true);
            temp.setWord(word);
        }
        StringBuilder builder = new StringBuilder();
        Set<String> ret = new HashSet<>();
        for (int i=0; i<board.length; i++) {
            for (int j=0; j<board[0].length; j++) {
                search(board, i, j, visited, ret, root);
            }
        }
        return new ArrayList<>(ret);
    }
    private void search(char[][] board, int i, int j, boolean[][] visited, Set<String> ret, TrieNode root) {
        if (i < 0 || i>= board.length || j<0 || j>= board[0].length) return;
        char c = board[i][j];
        if (visited[i][j]) return;
        if (root.children[c-'a'] != null) {
            root = root.children[c-'a'];
            if (root.getIsLeaf()) ret.add(root.getWord());
            visited[i][j] = true;
            search(board, i+1, j, visited, ret, root);
            search(board, i-1, j, visited, ret, root);
            search(board, i, j+1, visited, ret, root);
            search(board, i, j-1, visited, ret, root);
            visited[i][j] = false;
        }
    }
    public static class TrieNode {
        private TrieNode[] children;
        private boolean isLeaf;
        private String word;
        public TrieNode() {
            children = new TrieNode[26];
            isLeaf = false;
            word = null;
        }
        public void setWord(String word) {
            this.word = word;
        }
        public String getWord() {
            return word;
        }
        public void setIsLeaf(boolean isLeaf) {
            this.isLeaf = isLeaf;
            
        }
        public boolean getIsLeaf() {
            return isLeaf;
        }
    }
