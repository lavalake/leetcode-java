求subarry sum的问题，一般考虑用pre sum的方法
即
sum[i][j] = sum[0][j] - sum[0][i-1]
如果都是正整数，则可以考虑使用two pointer
560. Subarray Sum Equals K
https://leetcode.com/problems/subarray-sum-equals-k/description/
https://leetcode.com/problems/subarray-sum-equals-k/discuss/102106/Java-Solution-PreSum-+-HashMap
Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.

Example 1:
Input:nums = [1,1,1], k = 2
Output: 2

Solution 1. Brute force. We just need two loops (i, j) and test if SUM[i, j] = k. Time complexity O(n^2), Space complexity O(1). I bet this solution will TLE.

Solution 2. From solution 1, we know the key to solve this problem is SUM[i, j]. So if we know SUM[0, i - 1] and 
SUM[0, j], then we can easily get SUM[i, j]. To achieve this, we just need to go through the array, calculate the 
current sum and save number of all seen PreSum to a HashMap. Time complexity O(n), Space complexity O(n).

class Solution {
    public int subarraySum(int[] nums, int k) {
        int sum = 0, ret = 0;
        Map<Integer,Integer> mem = new HashMap<>();
        mem.put(0,1);
        for (int i : nums) {
            sum += i;
            if (mem.containsKey(sum - k)) {
                ret += mem.get(sum - k);
            }
            mem.put(sum, mem.getOrDefault(sum, 0)+1);
        }
        return ret;
    }
}

523. Continuous Subarray Sum
Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.

Example 1:
Input: [23, 2, 4, 6, 7],  k=6
Output: True
Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.
这道题目于上一道题目的不同是求K的倍数，所以我们要把余数放入map，不是sum

class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        int sum = 0;
        Map<Integer,Integer> mem = new HashMap<>();
        mem.put(0,0);
        for (int i=0; i<nums.length; i++) {
            sum += nums[i];
            int t = k==0?sum:sum%k;
            if (mem.containsKey(t)) {
                int prev = mem.get(t);
                if (i-prev + 1 > 1) return true;
            } else {
                /**************
                here, we cache the remaining of sum, not sum
                because only the remaining matters
                **************/
                mem.put(t,i+1);
            }
        }
        return false;
    }
}


713. Subarray Product Less Than K
Your are given an array of positive integers nums.

Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.

Example 1:
Input: nums = [10, 5, 2, 6], k = 100
Output: 8
Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].
Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.
这一题因为nums[i]都是正整数，我们可以用two pointer来做。
https://leetcode.com/problems/subarray-product-less-than-k/discuss/108861/JavaC++-Clean-Code-with-Explanation
The idea is always keep an max-product-window less than K;
Every time shift window by adding a new number on the right(j), if the product is greater than k, then try to reduce numbers on the left(i), until the subarray product fit less than k again, (subarray could be empty);
Each step introduces x new subarrays, where x is the size of the current window (j + 1 - i);
example:
for window (5, 2), when 6 is introduced, it add 3 new subarray: (5, (2, (6)))
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        int prd = 1;
        int right = 0, left = 0;
        int ret = 0;
        while (right < nums.length) {
            prd *= nums[right];
            while (prd >= k && left<=right) {
                prd /= nums[left++];
            }
            /*Each step introduces x new subarrays, where x is the size of the current window (j + 1 - i)
            */
            ret += right - left + 1;
            right++;
        }
        return ret;
    }
}


325. Maximum Size Subarray Sum Equals k
Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn't one, return 0 instead.

Note:
The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range.

Example 1:

Input: nums = [1, -1, 5, -2, 3], k = 3
Output: 4 
Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest.
解法类似560，但是因为求最长subarray，而不是subarray的个数， 所以map的value是第一次出现的index
class Solution {
    public int maxSubArrayLen(int[] nums, int k) {
        Map<Integer,Integer> mem = new HashMap<>();
        mem.put(0,-1);
        int sum = 0, ret = 0;
        for (int i=0; i<nums.length; i++) {
            sum += nums[i];
            if (mem.containsKey(sum - k)) {
                ret = Math.max(ret, i - mem.get(sum - k));
            }
                if (!mem.containsKey(sum))
                    mem.put(sum, i);
        }
        return ret;
    }
}


209. Minimum Size Subarray Sum
Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.

Example: 

Input: s = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: the subarray [4,3] has the minimal length under the problem constraint.

此题为正整数，所以可以用two pointer
class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        int sum = 0, left = 0, right = 0;
        int ret = Integer.MAX_VALUE;
        while (right < nums.length) {
            sum += nums[right];
            while (sum >= s && left <= right) {
                ret = Math.min(ret, right - left + 1);
                sum -= nums[left++];
            }
            right++;
        }
        return ret == Integer.MAX_VALUE?0:ret;
    }
}
