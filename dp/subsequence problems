1. Longest Increasing Subsequence
http://www.cnblogs.com/grandyang/p/4938187.html
首先来看一种动态规划Dynamic Programming的解法，这种解法的时间复杂度为O(n2)，类似brute force的解法，我们维护一个一维dp数组，
其中dp[i]表示以nums[i]为结尾的最长递增子串的长度，对于每一个nums[i]，我们从第一个数再搜索到i，如果发现某个数小于nums[i]，
我们更新dp[i]，更新方法为dp[i] = max(dp[i], dp[j] + 1)，即比较当前dp[i]的值和那个小于num[i]的数的dp值加1的大小，
我们就这样不断的更新dp数组，到最后dp数组中最大的值就是我们要返回的LIS的长度，
/**************
注意。最大值不一定是dp[N]。 所以要保存max
**************/
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 0) return 0;
        int max = 0;
        int[] dp = new int[nums.length];
        dp[0] = 1;
        for (int i=0; i<nums.length; i++) {
            for (int j=0; j<i; j++) {
                int seq = nums[i] > nums[j]?dp[j]+1:1;
                dp[i] = Math.max(dp[i], seq);
            }
            max = Math.max(max, dp[i]);
        }
        return max;
    }
}
