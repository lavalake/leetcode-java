
https://leetcode.com/problems/alien-dictionary/discuss/199954/My-2ms-Java-Solution-Topology-Sorting
/*
topologycal sort
bfs or dfs
https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/
1. need to consider circle
2. all remaining char which does not have any dependency
special
1. two equals string
wtr
wtr
rturn wtr
2. circle
wtr
wtf
wtr

wtr
etf
ftm
wab

3. other chars
wrt
e
output
wert
*/
class Solution {
    public String alienOrder(String[] words) {
        Map<Character, Set<Character>> graph = new HashMap<>();
        Set<Character> vertex = new HashSet<>();
        Set<Character> toVertex = new HashSet<>();
        Set<Character> visited = new HashSet<>();
        for (String word : words) {
            for (char c : word.toCharArray()) {
                visited.add(c);
            }
        }
        for (int i=1; i<words.length; i++) {
            for (int j=0; j<Math.min(words[i].length(), words[i-1].length()); j++) {
                if (words[i].charAt(j) != words[i-1].charAt(j)) {
                    int from = i-1, to = i;
                    if (!graph.containsKey(words[from].charAt(j))) {
                        graph.put(words[from].charAt(j), new HashSet<Character>());
                        vertex.add(words[from].charAt(j));
                    }
                    graph.get(words[from].charAt(j)).add(words[to].charAt(j));
                    vertex.remove(words[to].charAt(j));
                    toVertex.add(words[to].charAt(j));
                    break;
                }
            }
        }
        Deque<Character> stack = new LinkedList<>();
        StringBuilder result = new StringBuilder();
        for (char c : vertex) {
                    int[] color = new int[26];

            if (dfs(graph, c, stack, visited, color)) return "";
        }
        for (char c : visited) {
            stack.push(c);
        }
        while (!stack.isEmpty()) {
            result.append(stack.pop());
        }
        
        return result.toString();
    }
    private boolean dfs(Map<Character, Set<Character>> graph, char index, Deque<Character> stack, Set<Character> visited, int[] color) {
        
        if (!visited.contains(index)) return false;
        if (color[index-'a'] == 1) {
            return true;
        }
        color[index-'a'] = 1;
        if (graph.get(index) == null){
            stack.push(index);
                            visited.remove(index);

            return false;
        } 
        for (char c : graph.get(index)) {
            if (dfs(graph, c, stack, visited, color)) return true;
        }
                visited.remove(index);

        stack.push(index);
        color[index-'a'] = 0;
        return false;
    }
}
